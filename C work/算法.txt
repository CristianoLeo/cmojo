一般认为：“程序 = 算法 + 数据结构”。
算法是解决问题的逻辑、方法、步骤，数据结构是数据在计算机中的存储和访问方式。
算法和数据结构是紧密结合的，而且有些数据结构有特定的处理方法，很难把数据结构与算法区分开来

算法（Algorithm）是对特定问题求解步骤的一种描述，是指令的有限序列，
有以下5个特征：
    1) 输入：一个算法有零个输入或多个输入。算法可以没有输入，比如一个定时闹钟程序，
            它不需要输入，但是能够每隔一段时间就输出一个报警
    2) 输出：一个算法有一个或多个输出。程序可以没有输入，但是一定要有输出。
    3) 有穷性:一个算法必须在执行有穷步之后结束，且每步都在有穷时间内完成。
    3) 确定性:算法中的每条指令必须有确切的含义，对于相同的输入只能得到相同的输出。
    5) 可行性:算法描述的操作可以通过已经实现的基本操作执行有限次来实现




计算的资源是有限的，竞赛题会限制代码所使用的计算资源。
计算资源有两种：计算时间与存储时间，对应着时间复杂度与空间复杂度

时间复杂度不完全等于运行时间。由于代码的运行时间依赖于计算机的性能，同样的代码在
不同的机器上运行，需要的时间不同。所以直接把运行时间作为判断标准并不准确。
用代码执行的次数衡量更加合理，如一个for循环循环了n次，把它的时间复杂度记为O(n);


衡量算法性能的主要对象是时间复杂度，一般不讨论空间复杂度。

衡量一个算法运行时间最常见的一种方法是大O记号，表示一个算法或函数的渐进上界。
对于一个函数g(n),用O(g(n)) 表示一个函数集合，读作“g(n)的大O”。

O(g(n)) = { f(n) : 存在正常数 c 和 n0 ，使对所有的n >= n0,有0 <= f(n) <= cg(n) }。

用大O做算法分析，得到的复杂度只是一个上界估计。例如：在一个有n个数的无序数列中，查找
某个数x，可能第一个数就是x，也可能最后一个数才是x，平均查找次数为n / 2次，但是把查找的
时间记为O(n)而不是O(n/2)。在大O分析中，规模n前面的常数系数被省略了。



问题规模n   O(log2 n)   O(n)    O(nlog2 n)      O(n^2)      O(2^n)      O(n!)

n <= 11       √          √         √             √            √          √

n <= 25       √          √         √             √            √          ×

n <= 5000     √          √         √             √            ×          ×

n <= 10^6     √          √         √             ×            ×          ×

n <= 10^7     √          √         ×             ×            ×          ×

n > 10^8      √          ×         ×             ×            ×          ×


竞赛题的限制时间一般是1秒，对应普通计算机计算速度是每秒千万次级，例如一个算法的复杂度为
O(n!) ,当n = 11时，11! = 39916800,这个算法只能解决n <= 11的问题


前缀和：一个长度为n的数组，a[0] ~ a[n - 1],sum[i]代表数组a的前i个元素之和